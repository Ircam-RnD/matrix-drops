'use strict';

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _loop = require('./loop');

var _loop2 = _interopRequireDefault(_loop);

var _circle = require('./circle');

var _circle2 = _interopRequireDefault(_circle);

var _colorMap = require('./color-map');

var _colorMap2 = _interopRequireDefault(_colorMap);

// globals
var w = undefined,
    h = undefined;
// create canvas
var $canvas = undefined;
var ctx = undefined;

var setSize = function setSize() {
  // var style = window.getComputedStyle($canvas);
  // w = style.getPropertyValue('width');
  // h = style.getPropertyValue('height');
  w = window.innerWidth;
  h = window.innerHeight;
  ctx.canvas.width = w;
  ctx.canvas.height = h;
};

// store displayed circles
var circles = [];

// main loop functions
// const update = function(dt) {
//   // update and remove dead circles - avoid skipping next element when removing element
//   // http://stackoverflow.com/questions/16352546/how-to-iterate-over-an-array-and-remove-elements-in-javascript
//   for (let i = circles.length - 1; i >= 0; i--) {
//     const circle = circles[i];
//     circle.update(dt, w, h);

//     if (circle.isDead) { circles.splice(i, 1); }
//   }
// };

// const render = function(dt) {
//   ctx.fillStyle = '#000';
//   ctx.fillRect(0, 0, w, h);

//   for (var i = 0; i < circles.length; i++) {
//     circles[i].draw(ctx, dt);
//   }
// };

// game loop
var options = {
  ctx: ctx,
  buffers: [],
  update: update,
  render: render,
  fps: 60
  // gui: gui.model
};

exports['default'] = {
  // create a new circle
  // createCircle: function(message) {
  //   const circle = new Circle(message);
  //   circles.push(circle);
  //   return circle.id;
  // },

  // update a displayed circle lifetime
  updateDuration: function updateDuration(circleId, duration) {
    var target = undefined;

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = _getIterator(circles), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var circle = _step.value;

        if (circle.id !== circleId) {
          continue;
        }
        target = circle;
        break;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator['return']) {
          _iterator['return']();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    if (!target) {
      return false;
    }

    target.setDuration(time);
  },

  // start animation
  start: function start() {
    $canvas = document.querySelector('#scene');
    ctx = $canvas.getContext('2d');

    // apply window size to canvas - update globals
    setSize();
    window.addEventListener('resize', setSize);

    _loop2['default'].run(options);
  },

  remove: function remove(index) {
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = _getIterator(circles), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var circle = _step2.value;

        if (circle.index === index) circle.isDead = true;
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2['return']) {
          _iterator2['return']();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }
  },

  clear: function clear() {
    circles = [];
  },

  makeButton: function makeButton(container, index, x, y, func) {
    var posX = x * w;
    var posY = y * h;

    var el = document.createElement('div');
    el.classList.add('button');
    el.style.left = posX + 'px';
    el.style.top = posY + 'px';
    el.style.backgroundColor = _colorMap2['default'][index % _colorMap2['default'].length];

    el.addEventListener('touchstart', function onTouchStart(e) {
      e.preventDefault();
      el.removeEventListener(onTouchStart);
      func(index, x, y);
      container.removeChild(el);
    });

    container.appendChild(el);
  }

};
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNyYy9jbGllbnQvcGxheWVyL3Zpc3VhbC9tYWluLmpzLmJhayJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O29CQUFpQixRQUFROzs7O3NCQUNOLFVBQVU7Ozs7d0JBQ1IsYUFBYTs7Ozs7QUFHbEMsSUFBSSxDQUFDLFlBQUE7SUFBRSxDQUFDLFlBQUEsQ0FBQzs7QUFFVCxJQUFJLE9BQU8sWUFBQSxDQUFDO0FBQ1osSUFBSSxHQUFHLFlBQUEsQ0FBQzs7QUFFUixJQUFNLE9BQU8sR0FBRyxTQUFWLE9BQU8sR0FBYzs7OztBQUl6QixHQUFDLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQztBQUN0QixHQUFDLEdBQUcsTUFBTSxDQUFDLFdBQVcsQ0FBQztBQUN2QixLQUFHLENBQUMsTUFBTSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUM7QUFDckIsS0FBRyxDQUFDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO0NBQ3ZCLENBQUM7OztBQUdGLElBQUksT0FBTyxHQUFHLEVBQUUsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBd0JqQixJQUFNLE9BQU8sR0FBRztBQUNkLEtBQUcsRUFBRSxHQUFHO0FBQ1IsU0FBTyxFQUFFLEVBQUU7QUFDWCxRQUFNLEVBQUUsTUFBTTtBQUNkLFFBQU0sRUFBRSxNQUFNO0FBQ2QsS0FBRyxFQUFFLEVBQUU7O0NBRVIsQ0FBQzs7cUJBRWE7Ozs7Ozs7OztBQVNiLGdCQUFjLEVBQUUsd0JBQVMsUUFBUSxFQUFFLFFBQVEsRUFBRTtBQUMzQyxRQUFJLE1BQU0sWUFBQSxDQUFDOzs7Ozs7O0FBRVgsd0NBQW1CLE9BQU8sNEdBQUU7WUFBbkIsTUFBTTs7QUFDYixZQUFJLE1BQU0sQ0FBQyxFQUFFLEtBQUssUUFBUSxFQUFFO0FBQUUsbUJBQVM7U0FBRTtBQUN6QyxjQUFNLEdBQUcsTUFBTSxDQUFDO0FBQ2hCLGNBQU07T0FDUDs7Ozs7Ozs7Ozs7Ozs7OztBQUVELFFBQUksQ0FBQyxNQUFNLEVBQUU7QUFBRSxhQUFPLEtBQUssQ0FBQztLQUFFOztBQUU5QixVQUFNLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO0dBQzFCOzs7QUFHRCxPQUFLLEVBQUUsaUJBQVc7QUFDaEIsV0FBTyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLENBQUM7QUFDM0MsT0FBRyxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7OztBQUcvQixXQUFPLEVBQUUsQ0FBQztBQUNWLFVBQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLEVBQUUsT0FBTyxDQUFDLENBQUM7O0FBRTNDLHNCQUFLLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztHQUNuQjs7QUFFRCxRQUFNLEVBQUEsZ0JBQUMsS0FBSyxFQUFFOzs7Ozs7QUFDWix5Q0FBbUIsT0FBTyxpSEFBRTtZQUFuQixNQUFNOztBQUNiLFlBQUksTUFBTSxDQUFDLEtBQUssS0FBSyxLQUFLLEVBQ3hCLE1BQU0sQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDO09BQ3hCOzs7Ozs7Ozs7Ozs7Ozs7R0FDRjs7QUFFRCxPQUFLLEVBQUEsaUJBQUc7QUFDTixXQUFPLEdBQUcsRUFBRSxDQUFDO0dBQ2Q7O0FBRUQsWUFBVSxFQUFBLG9CQUFDLFNBQVMsRUFBRSxLQUFLLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLEVBQUU7QUFDdkMsUUFBTSxJQUFJLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUNuQixRQUFNLElBQUksR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDOztBQUVuQixRQUFNLEVBQUUsR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3pDLE1BQUUsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBQzNCLE1BQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLENBQUM7QUFDNUIsTUFBRSxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsSUFBSSxHQUFHLElBQUksQ0FBQztBQUMzQixNQUFFLENBQUMsS0FBSyxDQUFDLGVBQWUsR0FBRyxzQkFBUyxLQUFLLEdBQUcsc0JBQVMsTUFBTSxDQUFDLENBQUM7O0FBRTdELE1BQUUsQ0FBQyxnQkFBZ0IsQ0FBQyxZQUFZLEVBQUUsU0FBUyxZQUFZLENBQUMsQ0FBQyxFQUFFO0FBQ3pELE9BQUMsQ0FBQyxjQUFjLEVBQUUsQ0FBQztBQUNuQixRQUFFLENBQUMsbUJBQW1CLENBQUMsWUFBWSxDQUFDLENBQUM7QUFDckMsVUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDbEIsZUFBUyxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUMsQ0FBQztLQUMzQixDQUFDLENBQUM7O0FBRUgsYUFBUyxDQUFDLFdBQVcsQ0FBQyxFQUFFLENBQUMsQ0FBQztHQUMzQjs7Q0FFRiIsImZpbGUiOiJzcmMvY2xpZW50L3BsYXllci92aXN1YWwvbWFpbi5qcy5iYWsiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbG9vcCBmcm9tICcuL2xvb3AnO1xuaW1wb3J0IENpcmNsZSBmcm9tICcuL2NpcmNsZSc7XG5pbXBvcnQgY29sb3JNYXAgZnJvbSAnLi9jb2xvci1tYXAnO1xuXG4vLyBnbG9iYWxzXG5sZXQgdywgaDtcbi8vIGNyZWF0ZSBjYW52YXNcbmxldCAkY2FudmFzO1xubGV0IGN0eDtcblxuY29uc3Qgc2V0U2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAvLyB2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSgkY2FudmFzKTtcbiAgLy8gdyA9IHN0eWxlLmdldFByb3BlcnR5VmFsdWUoJ3dpZHRoJyk7XG4gIC8vIGggPSBzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKCdoZWlnaHQnKTtcbiAgdyA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICBoID0gd2luZG93LmlubmVySGVpZ2h0O1xuICBjdHguY2FudmFzLndpZHRoID0gdztcbiAgY3R4LmNhbnZhcy5oZWlnaHQgPSBoO1xufTtcblxuLy8gc3RvcmUgZGlzcGxheWVkIGNpcmNsZXNcbmxldCBjaXJjbGVzID0gW107XG5cbi8vIG1haW4gbG9vcCBmdW5jdGlvbnNcbi8vIGNvbnN0IHVwZGF0ZSA9IGZ1bmN0aW9uKGR0KSB7XG4vLyAgIC8vIHVwZGF0ZSBhbmQgcmVtb3ZlIGRlYWQgY2lyY2xlcyAtIGF2b2lkIHNraXBwaW5nIG5leHQgZWxlbWVudCB3aGVuIHJlbW92aW5nIGVsZW1lbnRcbi8vICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNjM1MjU0Ni9ob3ctdG8taXRlcmF0ZS1vdmVyLWFuLWFycmF5LWFuZC1yZW1vdmUtZWxlbWVudHMtaW4tamF2YXNjcmlwdFxuLy8gICBmb3IgKGxldCBpID0gY2lyY2xlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuLy8gICAgIGNvbnN0IGNpcmNsZSA9IGNpcmNsZXNbaV07XG4vLyAgICAgY2lyY2xlLnVwZGF0ZShkdCwgdywgaCk7XG5cbi8vICAgICBpZiAoY2lyY2xlLmlzRGVhZCkgeyBjaXJjbGVzLnNwbGljZShpLCAxKTsgfVxuLy8gICB9XG4vLyB9O1xuXG4vLyBjb25zdCByZW5kZXIgPSBmdW5jdGlvbihkdCkge1xuLy8gICBjdHguZmlsbFN0eWxlID0gJyMwMDAnO1xuLy8gICBjdHguZmlsbFJlY3QoMCwgMCwgdywgaCk7XG5cbi8vICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaXJjbGVzLmxlbmd0aDsgaSsrKSB7XG4vLyAgICAgY2lyY2xlc1tpXS5kcmF3KGN0eCwgZHQpO1xuLy8gICB9XG4vLyB9O1xuXG4vLyBnYW1lIGxvb3BcbmNvbnN0IG9wdGlvbnMgPSB7XG4gIGN0eDogY3R4LFxuICBidWZmZXJzOiBbXSxcbiAgdXBkYXRlOiB1cGRhdGUsXG4gIHJlbmRlcjogcmVuZGVyLFxuICBmcHM6IDYwXG4gIC8vIGd1aTogZ3VpLm1vZGVsXG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIC8vIGNyZWF0ZSBhIG5ldyBjaXJjbGVcbiAgLy8gY3JlYXRlQ2lyY2xlOiBmdW5jdGlvbihtZXNzYWdlKSB7XG4gIC8vICAgY29uc3QgY2lyY2xlID0gbmV3IENpcmNsZShtZXNzYWdlKTtcbiAgLy8gICBjaXJjbGVzLnB1c2goY2lyY2xlKTtcbiAgLy8gICByZXR1cm4gY2lyY2xlLmlkO1xuICAvLyB9LFxuXG4gIC8vIHVwZGF0ZSBhIGRpc3BsYXllZCBjaXJjbGUgbGlmZXRpbWVcbiAgdXBkYXRlRHVyYXRpb246IGZ1bmN0aW9uKGNpcmNsZUlkLCBkdXJhdGlvbikge1xuICAgIGxldCB0YXJnZXQ7XG5cbiAgICBmb3IgKGxldCBjaXJjbGUgb2YgY2lyY2xlcykge1xuICAgICAgaWYgKGNpcmNsZS5pZCAhPT0gY2lyY2xlSWQpIHsgY29udGludWU7IH1cbiAgICAgIHRhcmdldCA9IGNpcmNsZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmICghdGFyZ2V0KSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgdGFyZ2V0LnNldER1cmF0aW9uKHRpbWUpO1xuICB9LFxuXG4gIC8vIHN0YXJ0IGFuaW1hdGlvblxuICBzdGFydDogZnVuY3Rpb24oKSB7XG4gICAgJGNhbnZhcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNzY2VuZScpO1xuICAgIGN0eCA9ICRjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgIC8vIGFwcGx5IHdpbmRvdyBzaXplIHRvIGNhbnZhcyAtIHVwZGF0ZSBnbG9iYWxzXG4gICAgc2V0U2l6ZSgpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBzZXRTaXplKTtcblxuICAgIGxvb3AucnVuKG9wdGlvbnMpO1xuICB9LFxuXG4gIHJlbW92ZShpbmRleCkge1xuICAgIGZvciAobGV0IGNpcmNsZSBvZiBjaXJjbGVzKSB7XG4gICAgICBpZiAoY2lyY2xlLmluZGV4ID09PSBpbmRleClcbiAgICAgICAgY2lyY2xlLmlzRGVhZCA9IHRydWU7XG4gICAgfVxuICB9LFxuXG4gIGNsZWFyKCkge1xuICAgIGNpcmNsZXMgPSBbXTtcbiAgfSxcblxuICBtYWtlQnV0dG9uKGNvbnRhaW5lciwgaW5kZXgsIHgsIHksIGZ1bmMpIHtcbiAgICBjb25zdCBwb3NYID0geCAqIHc7XG4gICAgY29uc3QgcG9zWSA9IHkgKiBoO1xuXG4gICAgY29uc3QgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBlbC5jbGFzc0xpc3QuYWRkKCdidXR0b24nKTtcbiAgICBlbC5zdHlsZS5sZWZ0ID0gcG9zWCArICdweCc7XG4gICAgZWwuc3R5bGUudG9wID0gcG9zWSArICdweCc7XG4gICAgZWwuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gY29sb3JNYXBbaW5kZXggJSBjb2xvck1hcC5sZW5ndGhdO1xuXG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGZ1bmN0aW9uIG9uVG91Y2hTdGFydChlKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKG9uVG91Y2hTdGFydCk7XG4gICAgICBmdW5jKGluZGV4LCB4LCB5KTtcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChlbCk7XG4gICAgfSk7XG5cbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwpO1xuICB9XG5cbn07XG4iXX0=